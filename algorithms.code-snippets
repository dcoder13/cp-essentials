{
    "fenwick tree classic template": {
        "prefix": "fenwicktree",
        "body": [
            "class Node {",
            "    public:",
            "    int val;",
            "    Node() : val(0) {}",
            "    Node(int x) : val(x){}",
            "    void add(int val) {",
            "        this->val += val;",
            "    }",
            "};",
            "class BIT {",
            "    int n;",
            "    vector<Node> B1, B2;",
            "    public:",
            "    BIT(int n) {",
            "        this-> n = n;",
            "        B1.assign(n+1, Node());",
            "        B2.assign(n+1, Node());",
            "    }",
            "    BIT(vector<int> a) : BIT(a.size()) {",
            "        for(int i = 0; i<n; i++) {",
            "            range_add(i, i, a[i]);",
            "        }",
            "    }",
            "    void range_add(int l, int r,int x) {",
            "        add(B1, l, x);",
            "        add(B1, r+1, -x);",
            "        add(B2, l, x*(l-1));",
            "        add(B2, r+1, -x*r);",
            "    }",
            "    int sum(vector<Node> &tree, int i) {",
            "        Node ret = Node();",
            "        for(++i; i>0; i-=i&-i) ret.add(tree[i].val);",
            "        return (ret.val); ",
            "    }",
            "",
            "    int prefix_sum(int idx) {",
            "        return sum(B1, idx)*idx -  sum(B2, idx);",
            "    }",
            "",
            "    int range_sum(int l, int r) {",
            "        return prefix_sum(r) - prefix_sum(l-1);",
            "    }",
            "",
            "    void add(vector<Node> &tree, int i, int val) {",
            "        for(++i; i<=n; i+=i & -i) tree[i].add(val);",
            "    }",
            "};"
        ],
        "description": "fenwick tree classic template"
    },
    "Rolling Hash": {
        "prefix": "rollhash",
        "body": [
            "class rollhash {",
            "    int M0 = 1e9 + 7, M1 = 1e9 + 9;",
            "    int b = 29, n;",
            "    vector<array<int, 2>> fwd, rev;",
            "    vector<array<int, 2>> p;",
            "    int binexpo(int base, int power, int M) {",
            "        int res = 1;",
            "        while(power) {",
            "            if(power & 1) {",
            "                power--;",
            "                res *= base % M;",
            "                res %= M;",
            "            } else {",
            "                power /= 2;",
            "                base *= base % M;",
            "                base %= M;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "  public:",
            "    rollhash(string s) : fwd(s.size() + 2), rev(s.size() + 2), p(s.size() + 1) {",
            "        n = s.size();",
            "        p[0][0] = p[1][0] = p[0][1] = p[1][1] = 1;",
            "        for(int i = 2; i <= n; i++) p[i][0] = (p[i - 1][0] * b) % M0, p[i][1] = p[i - 1][1] * b % M1;",
            "        for(int i = 1; i <= n; i++) {",
            "            fwd[i][0] = fwd[i - 1][0] + (s[i - 1] - 'a' + 1) * p[i][0];",
            "            fwd[i][1] = fwd[i - 1][1] + (s[i - 1] - 'a' + 1) * p[i][1];",
            "            fwd[i][0] %= M0;",
            "            fwd[i][1] %= M1;",
            "        }",
            "        for(int i = n; i >= 1; i--) {",
            "            rev[i][0] = rev[i + 1][0] + (s[i - 1] - 'a' + 1) * p[n - i + 1][0];",
            "            rev[i][1] = rev[i + 1][1] + (s[i - 1] - 'a' + 1) * p[n - i + 1][1];",
            "            rev[i][0] %= M0;",
            "            rev[i][1] %= M1;",
            "        }",
            "    }",
            "    array<array<int, 2>, 2> gethash(int l, int r) {",
            "        array<array<int, 2>, 2> ret;",
            "        ret[0][0] = ((fwd[r][0] - fwd[l - 1][0] + M0) % M0) * binexpo(p[l][0], M0 - 2, M0) % M0;",
            "        ret[0][1] = ((fwd[r][1] - fwd[l - 1][1] + M1) % M1) * binexpo(p[l][1], M1 - 2, M1) % M1;",
            "        ret[1][0] = ((rev[l][0] - rev[r + 1][0] + M0) % M0) * binexpo(p[n - r + 1][0], M0 - 2, M0) % M0;",
            "        ret[1][1] = ((rev[l][1] - rev[r + 1][1] + M1) % M1) * binexpo(p[n - r + 1][1], M1 - 2, M1) % M1;",
            "        return ret;",
            "    }",
            "};"
        ],
        "description": "Rolling Hash"
    },
    "Sparse Table": {
        "prefix": "Sparse Table",
        "body": [
            "typedef struct SparseTable {",
            "    private:",
            "    int n;",
            "    vector<vector<int>> st;",
            "    int base = INT_MAX; // might change",
            "    int log_f(int n) {",
            "        return (int)__builtin_clzll(1) - (int)__builtin_clzll(n);",
            "    }",
            "    int op(int a, int b) {",
            "        return min(a, b);",
            "    }",
            "    void build() {",
            "        for(int i = 1; i<=log_f(n); i++) {",
            "            for(int j = 0; j+(1<<i) <= n; j++) {",
            "                st[i][j] = op(st[i-1][j], st[i-1][j + (1<<(i-1))]);",
            "            }",
            "        }",
            "    }",
            "    public:",
            "    int query(int l, int r) {",
            "        if(l>r)return base;",
            "        int i = log_f(r-l+1);",
            "        return op(st[i][l], query(l+(1<<i), r));",
            "    }",
            "    int rmq(int l, int r) {",
            "        int i = log_f(r-l+1);",
            "        return op(st[i][l], st[i][r-(1<<i) + 1]);",
            "    }",
            "    SparseTable(int n, vector<int> &a) {",
            "        st.resize(log_f(n)+1, vector<int>(n));",
            "        st[0] = a;",
            "        this->n = n;",
            "        build();",
            "    }   ",
            "} sparse;"
        ],
        "description": "Sparse Table"
    },
    "binary Exponentiation": {
        "prefix": "binexpo",
        "body": [
            "int binexpo(int base , int power)",
            "{",
            "    int res=1;",
            "    while(power)",
            "    {",
            "        if(power&1)",
            "        {",
            "            power--;",
            "            res*=base%M;",
            "            res%=M;",
            "        }",
            "        else",
            "        {",
            "            power/=2;",
            "            base*=base%M;",
            "            base%=M;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "binary Exponentiation"
    },
    "matrix exponentiation": {
        "prefix": "matrix-exponentiation",
        "body": [
            "class Matrix{",
            "    public:",
            "    int n;",
            "    vector<vector<int>> m;",
            "    Matrix(int n, vector<vector<int>> m){",
            "        this->n = n;",
            "        this->m = m;",
            "    }",
            "    Matrix(int n){",
            "        this->n = n;",
            "        m=vector<vector<int>>(n, vector<int>(n, 0));",
            "    }",
            "    Matrix operator *(const Matrix &other){",
            "        Matrix p = Matrix(n);",
            "        for(int i=0; i<n; i++)",
            "        for(int j=0; j<n; j++)",
            "        for(int k=0; k<n; k++){",
            "            p.m[i][k]+=m[i][j]*other.m[j][k];",
            "            p.m[i][k]%=M;",
            "        }",
            "        return p;",
            "    }",
            "};",
            "",
            "Matrix matexpo(int n, Matrix base, int pow){",
            "    Matrix res(n);",
            "    for(int i=0; i<n; i++)",
            "    res.m[i][i]=1;",
            "    while(pow){",
            "        if(pow%2){",
            "            res = res*base;",
            "            pow--;",
            "        }else{",
            "            base = base*base;",
            "            pow/=2;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "matrix exponentiation"
    },
    "binsearch": {
        "scope": "cpp",
        "prefix": "binary search",
        "body": [
            "int lo=${1:0} , hi=${2:n} , mid;",
            "while(lo<=hi) {",
            "\tmid=(lo+hi)/2;",
            "\tif($0) {",
            "\t\tlo=mid+1;",
            "\t}",
            "\telse {",
            "\t\thi=mid-1;",
            "\t}",
            "}"
        ],
        "description": "binary search snippet"
    },
    "disjoint set": {
        "prefix": "dsu",
        "body": [
            "class dsu {",
            "  public:",
            "    vector<int> p, sz;",
            "    dsu(int n) {",
            "        sz.resize(n, 1);",
            "        p.resize(n);",
            "        iota(p.begin(), p.end(), 0);",
            "    }",
            "    int get(int a) {",
            "        return p[a] = (p[a] == a ? a : get(p[a]));",
            "    }",
            "    void un(int a, int b) {",
            "        a = get(a);",
            "        b = get(b);",
            "        if(a == b)return;",
            "        if(sz[a] < sz[b]) {",
            "            swap(a, b);",
            "        }",
            "        sz[a] += sz[b];",
            "        p[b] = a;",
            "    }",
            "};"
        ],
        "description": "disjoint set union (by size)"
    },
    "segment tree implementation": {
        "scope": "cpp",
        "prefix": "segment tree",
        "body": [
            "template <typename T>",
            "class segtree{",
            "    private:",
            "        int sizee;",
            "        vector<T> tree;",
            "        void init(int n){",
            "            sizee = 1;",
            "            while(sizee < n) sizee *= 2;",
            "            tree.resize(2*sizee-1, 0);",
            "        }",
            "        T operation(T a, T b)",
            "        {",
            "            return a + b;",
            "        }",
            "        void build(vector<T> &a, int x, int lx, int rx){",
            "            if(rx - lx == 1){",
            "                if(lx < (int)a.size()){",
            "                    tree[x] = a[lx];",
            "                }",
            "                return;",
            "            }",
            "            int m = (lx + rx)/2;",
            "            build(a, 2*x+1, lx, m);",
            "            build(a, 2*x+2, m, rx);",
            "            tree[x] = operation(tree[2*x+1], tree[2*x+2]);",
            "        }",
            "        T get(int l, int r, int x, int lx, int rx){",
            "            if(lx >= r || l >= rx) return 0;",
            "            if(lx >= l && rx <= r) return tree[x];",
            "            int m = (lx + rx)/2;",
            "            T s1 = get(l, r, 2*x+1, lx, m);",
            "            T s2 = get(l, r, 2*x+2, m, rx);",
            "            return operation(s1, s2);",
            "        }",
            "        void set(int i, int x, int lx, int rx, T v){",
            "            if(rx - lx == 1){",
            "                tree[x] = v;",
            "                return;",
            "            }",
            "            int m = (lx + rx)/2;",
            "            if(i < m){",
            "                set(i, 2*x+1, lx, m, v);",
            "            }",
            "            else{",
            "                set(i, 2*x+2, m, rx, v);",
            "            }",
            "            tree[x] = operation(tree[2*x+1], tree[2*x+2]);",
            "        }",
            "    public:",
            "        segtree(int n){",
            "            init(n);",
            "        }",
            "        segtree(int n, vector<T> a){",
            "            init(n);",
            "            build(a, 0, 0, sizee);",
            "        }",
            "        int size(){",
            "            return sizee;",
            "        }",
            "        // L to R-1",
            "        T get(int l, int r){ ",
            "            return get(l, r, 0, 0, sizee);",
            "        }",
            "        void set(int i, T v){",
            "            set(i, 0, 0, sizee, v);",
            "        }",
            "        // operator overloading",
            "        segtree operator=(segtree &other){",
            "            size = other.size;",
            "            tree = other.tree;",
            "            return *this;",
            "        }",
            "        T operator[](int i){",
            "            return tree[i];",
            "        }",
            "};",
            ""
        ],
        "description": "segment tree implementation"
    },
    "lambda function boiler plate": {
        "scope": "cpp, c++",
        "prefix": "lambda",
        "body": [
            "auto ${1:name} = [&] (${2:int n}, ${3:auto &&${1:self}}) -> ${4:void} {",
            "\t$0",
            "};",
        ]
    },
    "sieve low prime": {
        "prefix": "sieve",
        "body": [
            "vector<int> lowprime(int N)",
            "{",
            "    vector<int> lp(N+1,0) ,prime(N+1,0);",
            "",
            "    for(int i=2; i<=N; i++)",
            "    {",
            "        if(!prime[i])",
            "        {",
            "            lp[i]=i;",
            "            for(int j=i; j<N/i +1; j++)",
            "            {",
            "                prime[i*j]=1;",
            "                if(!lp[j*i])",
            "                    lp[i*j]=i;",
            "            }",
            "        }",
            "    }",
            "    return lp;",
            "}"
        ],
        "description": "sieve low prime"
    },
    "centroid decomposition": {
        "prefix": "centroid",
        "body": [
            "",
            "const int N  = 1e5;",
            "vector<int> adj[N];",
            "int dead[N];",
            "int sz[N];",
            "int n, k, ans = 0;",
            "void dfs(int node, int p=-1) {",
            "    sz[node] =1;",
            "    for(auto &x : adj[node]) if(!dead[x] and x!=p){",
            "        dfs(x, node);",
            "        sz[node]+=sz[x];",
            "    }",
            "}",
            "",
            "int find_centroid(int node, int cursz, int p=-1) {",
            "    for(auto &x : adj[node])if(!dead[x] && x!=p) {",
            "        if(sz[x]*2 > cursz)return find_centroid(x, cursz, node);",
            "    }",
            "    return node;",
            "}",
            "",
            "void decompose(int node, int cursz) {",
            "    dfs(node);",
            "    int ct = find_centroid(node, cursz);",
            "    dead[ct] = 1;",
            "    for(auto &x : adj[ct]) if(!dead[x]) {",
            "        decompose(x, sz[x]);",
            "    }",
            "}"
        ],
        "description": "centroid decomposition"
    },
    "modular int": {
        "prefix": "modint",
        "body": [
            "template<int mod>",
            "struct mint {",
            "    static const int MOD = mod;",
            "    int v;",
            "    explicit operator int() const {",
            "        return v;    // explicit -> don't silently convert to int",
            "    }",
            "    mint(): v(0) {}",
            "    mint(int _v) {",
            "        v = (int)((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "        if(v < 0) v += MOD;",
            "    }",
            "    bool operator==(const mint& o) const {",
            "        return v == o.v;",
            "    }",
            "    friend bool operator!=(const mint& a, const mint& b) {",
            "        return !(a == b);",
            "    }",
            "    friend bool operator<(const mint& a, const mint& b) {",
            "        return a.v < b.v;",
            "    }",
            "    mint& operator+=(const mint& o) {",
            "        if((v += o.v) >= MOD) v -= MOD;",
            "        return *this;",
            "    }",
            "    mint& operator-=(const mint& o) {",
            "        if((v -= o.v) < 0) v += MOD;",
            "        return *this;",
            "    }",
            "    mint& operator*=(const mint& o) {",
            "        v = (int)((int)v * o.v % MOD);",
            "        return *this;",
            "    }",
            "    mint& operator/=(const mint& o) {",
            "        return (*this) *= inv(o);",
            "    }",
            "    friend mint pow(mint a, int p) {",
            "        mint ans = 1;",
            "        for(; p; p /= 2, a *= a) if(p & 1) ans *= a;",
            "        return ans;",
            "    }",
            "    friend mint inv(const mint& a) {",
            "        return pow(a, MOD - 2);",
            "    }",
            "",
            "    mint operator-() const {",
            "        return mint(-v);",
            "    }",
            "    mint& operator++() {",
            "        return *this += 1;",
            "    }",
            "    mint& operator--() {",
            "        return *this -= 1;",
            "    }",
            "    friend mint operator+(mint a, const mint& b) {",
            "        return a += b;",
            "    }",
            "    friend mint operator-(mint a, const mint& b) {",
            "        return a -= b;",
            "    }",
            "    friend mint operator*(mint a, const mint& b) {",
            "        return a *= b;",
            "    }",
            "    friend mint operator/(mint a, const mint& b) {",
            "        return a /= b;",
            "    }",
            "    friend istream& operator>>(istream& is, mint& m) {",
            "        is >> m.v;",
            "        m.v = (m.v % MOD + MOD) % MOD;",
            "        return is;",
            "    }",
            "",
            "    friend ostream& operator<<(ostream& os, const mint& m) {",
            "        return os << m.v;",
            "    }",
            "};"
        ],
        "description": "modular int"
    },
    "better hashmap": {
        "prefix": "cmap",
        "body": [
            "struct chash {",
            "    const long double PI = 3.14;",
            "    const uint64_t C = uint64_t(2e18 * PI) + 71;",
            "    // random 32-bit number",
            "    const uint32_t RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "    size_t operator()(uint64_t x) const {",
            "        return __builtin_bswap64((x ^ RANDOM) * C);",
            "    }",
            "};",
            "template <class K, class V> using cmap = unordered_map<K, V, chash>;",
            ""
        ],
        "description": "better hashmap"
    },
}