{
	"fenwick tree classic template": {
		"prefix": "fenwicktree",
		"body": [
			"class Node {",
			"    public:",
			"    int val;",
			"    Node() : val(0) {}",
			"    Node(int x) : val(x){}",
			"    void add(int val) {",
			"        this->val += val;",
			"    }",
			"};",
			"class BIT {",
			"    int n;",
			"    vector<Node> B1, B2;",
			"    public:",
			"    BIT(int n) {",
			"        this-> n = n;",
			"        B1.assign(n+1, Node());",
			"        B2.assign(n+1, Node());",
			"    }",
			"    BIT(vector<int> a) : BIT(a.size()) {",
			"        for(int i = 0; i<n; i++) {",
			"            range_add(i, i, a[i]);",
			"        }",
			"    }",
			"    void range_add(int l, int r,int x) {",
			"        add(B1, l, x);",
			"        add(B1, r+1, -x);",
			"        add(B2, l, x*(l-1));",
			"        add(B2, r+1, -x*r);",
			"    }",
			"    int sum(vector<Node> &tree, int i) {",
			"        Node ret = Node();",
			"        for(++i; i>0; i-=i&-i) ret.add(tree[i].val);",
			"        return (ret.val); ",
			"    }",
			"",
			"    int prefix_sum(int idx) {",
			"        return sum(B1, idx)*idx -  sum(B2, idx);",
			"    }",
			"",
			"    int range_sum(int l, int r) {",
			"        return prefix_sum(r) - prefix_sum(l-1);",
			"    }",
			"",
			"    void add(vector<Node> &tree, int i, int val) {",
			"        for(++i; i<=n; i+=i & -i) tree[i].add(val);",
			"    }",
			"};"
		],
		"description": "fenwick tree classic template"
	},
	"Rolling Hash": {
		"prefix": "rollhash",
		"body": [
			"class rollhash {",
			"    int M0 = 1e9 + 7, M1 = 1e9 + 9;",
			"    int b = 29, n;",
			"    vector<array<int, 2>> fwd, rev;",
			"    vector<array<int, 2>> p;",
			"    int binexpo(int base, int power, int M) {",
			"        int res = 1;",
			"        while(power) {",
			"            if(power & 1) {",
			"                power--;",
			"                res *= base % M;",
			"                res %= M;",
			"            } else {",
			"                power /= 2;",
			"                base *= base % M;",
			"                base %= M;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"  public:",
			"    rollhash(string s) : fwd(s.size() + 2), rev(s.size() + 2), p(s.size() + 1) {",
			"        n = s.size();",
			"        p[0][0] = p[1][0] = p[0][1] = p[1][1] = 1;",
			"        for(int i = 2; i <= n; i++) p[i][0] = (p[i - 1][0] * b) % M0, p[i][1] = p[i - 1][1] * b % M1;",
			"        for(int i = 1; i <= n; i++) {",
			"            fwd[i][0] = fwd[i - 1][0] + (s[i - 1] - 'a' + 1) * p[i][0];",
			"            fwd[i][1] = fwd[i - 1][1] + (s[i - 1] - 'a' + 1) * p[i][1];",
			"            fwd[i][0] %= M0;",
			"            fwd[i][1] %= M1;",
			"        }",
			"        for(int i = n; i >= 1; i--) {",
			"            rev[i][0] = rev[i + 1][0] + (s[i - 1] - 'a' + 1) * p[n - i + 1][0];",
			"            rev[i][1] = rev[i + 1][1] + (s[i - 1] - 'a' + 1) * p[n - i + 1][1];",
			"            rev[i][0] %= M0;",
			"            rev[i][1] %= M1;",
			"        }",
			"    }",
			"    array<array<int, 2>, 2> gethash(int l, int r) {",
			"        array<array<int, 2>, 2> ret;",
			"        ret[0][0] = ((fwd[r][0] - fwd[l - 1][0] + M0) % M0) * binexpo(p[l][0], M0 - 2, M0) % M0;",
			"        ret[0][1] = ((fwd[r][1] - fwd[l - 1][1] + M1) % M1) * binexpo(p[l][1], M1 - 2, M1) % M1;",
			"        ret[1][0] = ((rev[l][0] - rev[r + 1][0] + M0) % M0) * binexpo(p[n - r + 1][0], M0 - 2, M0) % M0;",
			"        ret[1][1] = ((rev[l][1] - rev[r + 1][1] + M1) % M1) * binexpo(p[n - r + 1][1], M1 - 2, M1) % M1;",
			"        return ret;",
			"    }",
			"};"
		],
		"description": "Rolling Hash"
	},
	"Sparse Table": {
		"prefix": "Sparse Table",
		"body": [
			"typedef struct SparseTable {",
			"    private:",
			"    int n;",
			"    vector<vector<int>> st;",
			"    int base = INT_MAX; // might change",
			"    int log_f(int n) {",
			"        return (int)__builtin_clzll(1) - (int)__builtin_clzll(n);",
			"    }",
			"    int op(int a, int b) {",
			"        return min(a, b);",
			"    }",
			"    void build() {",
			"        for(int i = 1; i<=log_f(n); i++) {",
			"            for(int j = 0; j+(1<<i) <= n; j++) {",
			"                st[i][j] = op(st[i-1][j], st[i-1][j + (1<<(i-1))]);",
			"            }",
			"        }",
			"    }",
			"    public:",
			"    int query(int l, int r) {",
			"        if(l>r)return base;",
			"        int i = log_f(r-l+1);",
			"        return op(st[i][l], query(l+(1<<i), r));",
			"    }",
			"    int rmq(int l, int r) {",
			"        int i = log_f(r-l+1);",
			"        return op(st[i][l], st[i][r-(1<<i) + 1]);",
			"    }",
			"    SparseTable(int n, vector<int> &a) {",
			"        st.resize(log_f(n)+1, vector<int>(n));",
			"        st[0] = a;",
			"        this->n = n;",
			"        build();",
			"    }   ",
			"} sparse;"
		],
		"description": "Sparse Table"
	},
	"binary Exponentiation": {
		"prefix": "binexpo",
		"body": [
			"int binexpo(int base , int power)",
			"{",
			"    int res=1;",
			"    while(power)",
			"    {",
			"        if(power&1)",
			"        {",
			"            power--;",
			"            res*=base%M;",
			"            res%=M;",
			"        }",
			"        else",
			"        {",
			"            power/=2;",
			"            base*=base%M;",
			"            base%=M;",
			"        }",
			"    }",
			"    return res;",
			"}"
		],
		"description": "binary Exponentiation"
	},
	"matrix exponentiation": {
		"prefix": "matrix-exponentiation",
		"body": [
			"class Matrix{",
			"    public:",
			"    int n;",
			"    vector<vector<int>> m;",
			"    Matrix(int n, vector<vector<int>> m){",
			"        this->n = n;",
			"        this->m = m;",
			"    }",
			"    Matrix(int n){",
			"        this->n = n;",
			"        m=vector<vector<int>>(n, vector<int>(n, 0));",
			"    }",
			"    Matrix operator *(const Matrix &other){",
			"        Matrix p = Matrix(n);",
			"        for(int i=0; i<n; i++)",
			"        for(int j=0; j<n; j++)",
			"        for(int k=0; k<n; k++){",
			"            p.m[i][k]+=m[i][j]*other.m[j][k];",
			"            p.m[i][k]%=M;",
			"        }",
			"        return p;",
			"    }",
			"};",
			"",
			"Matrix matexpo(int n, Matrix base, int pow){",
			"    Matrix res(n);",
			"    for(int i=0; i<n; i++)",
			"    res.m[i][i]=1;",
			"    while(pow){",
			"        if(pow%2){",
			"            res = res*base;",
			"            pow--;",
			"        }else{",
			"            base = base*base;",
			"            pow/=2;",
			"        }",
			"    }",
			"    return res;",
			"}"
		],
		"description": "matrix exponentiation"
	},
	"binsearch": {
		"scope": "cpp",
		"prefix": "binary search",
		"body": [
			"int lo=${1:0} , hi=${2:n} , mid;",
			"while(lo<=hi) {",
			"\tmid=(lo+hi)/2;",
			"\tif($0) {",
			"\t\tlo=mid+1;",
			"\t}",
			"\telse {",
			"\t\thi=mid-1;",
			"\t}",
			"}"
		],
		"description": "binary search snippet"
	},
	"disjoint set": {
		"prefix": "dsu",
		"body": [
			"class dsu {",
			"  public:",
			"    vector<int> p, sz;",
			"    dsu(int n) {",
			"        sz.resize(n, 1);",
			"        p.resize(n);",
			"        iota(p.begin(), p.end(), 0);",
			"    }",
			"    int get(int a) {",
			"        return p[a] = (p[a] == a ? a : get(p[a]));",
			"    }",
			"    void un(int a, int b) {",
			"        a = get(a);",
			"        b = get(b);",
			"        if(a == b)return;",
			"        if(sz[a] < sz[b]) {",
			"            swap(a, b);",
			"        }",
			"        sz[a] += sz[b];",
			"        p[b] = a;",
			"    }",
			"};"
		],
		"description": "disjoint set union (by size)"
	},
	"segment tree implementation": {
		"prefix": "segment tree",
		"body": [
			"template <typename T>",
			"class segtree{",
			"    private:",
			"        int sizee;",
			"        vector<T> tree;",
			"        T base;",
			"        void build(vector<T> &a, int x, int lx, int rx){",
			"            if(rx - lx == 1){",
			"                if(lx < (int)a.size()){",
			"                    tree[x] = a[lx];",
			"                }",
			"                return;",
			"            }",
			"            int m = (lx + rx)/2;",
			"            build(a, 2*x+1, lx, m);",
			"            build(a, 2*x+2, m, rx);",
			"            tree[x] = operation(tree[2*x+1], tree[2*x+2]);",
			"        }",
			"        T get(int l, int r, int x, int lx, int rx) {",
			"            if(lx >= r || l >= rx) return base;",
			"            if(lx >= l && rx <= r) return tree[x];",
			"            int m = (lx + rx)/2;",
			"            return operation(get(l, r, 2*x+1, lx, m), get(l, r, 2*x+2, m, rx));",
			"        }",
			"        void set(int i, int x, int lx, int rx, T v){",
			"            if(rx - lx == 1){",
			"                tree[x] = v;",
			"                return;",
			"            }",
			"            int m = (lx + rx)/2;",
			"            if(i < m){",
			"                set(i, 2*x+1, lx, m, v);",
			"            } else {",
			"                set(i, 2*x+2, m, rx, v);",
			"            }",
			"            tree[x] = operation(tree[2*x+1], tree[2*x+2]);",
			"        }",
			"        T operation(T a, T b) {",
			"            return a + b;",
			"        }",
			"    public:",
			"        segtree(int n){",
			"            sizee = 1;",
			"            base = 0;",
			"            while(sizee < n) sizee *= 2;",
			"            tree.resize(2*sizee-1, base);",
			"        }",
			"        segtree(int n, vector<T> a) : segtree(n) {",
			"            build(a, 0, 0, sizee);",
			"        }",
			"        void set(int i, T v) { set(i, 0, 0, sizee, v);}",
			"        T get(int l, int r) { return get(l, r, 0, 0, sizee);}",
			"};"
		],
		"description": "segment tree implementation"
	},
	"lambda function boiler plate": {
		"scope": "cpp, c++",
		"prefix": "lambda",
		"body": [
			"auto ${1:name} = [&] (${2:int n}, ${3:auto &&${1:self}}) -> ${4:void} {",
			"\t$0",
			"};",
		]
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"vector<int> lowprime(int N)",
			"{",
			"    vector<int> lp(N+1,0) ,prime(N+1,0);",
			"",
			"    for(int i=2; i<=N; i++)",
			"    {",
			"        if(!prime[i])",
			"        {",
			"            lp[i]=i;",
			"            for(int j=i; j<N/i +1; j++)",
			"            {",
			"                prime[i*j]=1;",
			"                if(!lp[j*i])",
			"                    lp[i*j]=i;",
			"            }",
			"        }",
			"    }",
			"    return lp;",
			"}"
		],
		"description": "returns lowest prime vector"
	},
	"centroid decomposition": {
		"prefix": "centroid",
		"body": [
			"",
			"const int N  = 1e5;",
			"vector<int> adj[N];",
			"int dead[N];",
			"int sz[N];",
			"int n, k, ans = 0;",
			"void dfs(int node, int p=-1) {",
			"    sz[node] =1;",
			"    for(auto &x : adj[node]) if(!dead[x] and x!=p){",
			"        dfs(x, node);",
			"        sz[node]+=sz[x];",
			"    }",
			"}",
			"",
			"int find_centroid(int node, int cursz, int p=-1) {",
			"    for(auto &x : adj[node])if(!dead[x] && x!=p) {",
			"        if(sz[x]*2 > cursz)return find_centroid(x, cursz, node);",
			"    }",
			"    return node;",
			"}",
			"",
			"void decompose(int node, int cursz) {",
			"    dfs(node);",
			"    int ct = find_centroid(node, cursz);",
			"    dead[ct] = 1;",
			"    for(auto &x : adj[ct]) if(!dead[x]) {",
			"        decompose(x, sz[x]);",
			"    }",
			"}"
		],
		"description": "centroid decomposition"
	},
	"modular int": {
		"prefix": "modint",
		"body": [
			"template<int mod>",
			"struct mint {",
			"    static const int MOD = mod;",
			"    int v;",
			"    explicit operator int() const {",
			"        return v;    // explicit -> don't silently convert to int",
			"    }",
			"    mint(): v(0) {}",
			"    mint(int _v) {",
			"        v = (int)((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
			"        if(v < 0) v += MOD;",
			"    }",
			"    bool operator==(const mint& o) const {",
			"        return v == o.v;",
			"    }",
			"    friend bool operator!=(const mint& a, const mint& b) {",
			"        return !(a == b);",
			"    }",
			"    friend bool operator<(const mint& a, const mint& b) {",
			"        return a.v < b.v;",
			"    }",
			"    mint& operator+=(const mint& o) {",
			"        if((v += o.v) >= MOD) v -= MOD;",
			"        return *this;",
			"    }",
			"    mint& operator-=(const mint& o) {",
			"        if((v -= o.v) < 0) v += MOD;",
			"        return *this;",
			"    }",
			"    mint& operator*=(const mint& o) {",
			"        v = (int)((int)v * o.v % MOD);",
			"        return *this;",
			"    }",
			"    mint& operator/=(const mint& o) {",
			"        return (*this) *= inv(o);",
			"    }",
			"    friend mint pow(mint a, int p) {",
			"        mint ans = 1;",
			"        for(; p; p /= 2, a *= a) if(p & 1) ans *= a;",
			"        return ans;",
			"    }",
			"    friend mint inv(const mint& a) {",
			"        return pow(a, MOD - 2);",
			"    }",
			"",
			"    mint operator-() const {",
			"        return mint(-v);",
			"    }",
			"    mint& operator++() {",
			"        return *this += 1;",
			"    }",
			"    mint& operator--() {",
			"        return *this -= 1;",
			"    }",
			"    friend mint operator+(mint a, const mint& b) {",
			"        return a += b;",
			"    }",
			"    friend mint operator-(mint a, const mint& b) {",
			"        return a -= b;",
			"    }",
			"    friend mint operator*(mint a, const mint& b) {",
			"        return a *= b;",
			"    }",
			"    friend mint operator/(mint a, const mint& b) {",
			"        return a /= b;",
			"    }",
			"    friend istream& operator>>(istream& is, mint& m) {",
			"        is >> m.v;",
			"        m.v = (m.v % MOD + MOD) % MOD;",
			"        return is;",
			"    }",
			"",
			"    friend ostream& operator<<(ostream& os, const mint& m) {",
			"        return os << m.v;",
			"    }",
			"};"
		],
		"description": "modular int"
	},
	"hashmap": {
		"prefix": "hashmap",
		"body": [
			"",
			"struct chash {",
			"    static uint64_t splitmix64(uint64_t x) {",
			"        // http://xorshift.di.unimi.it/splitmix64.c",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    size_t operator()(uint64_t x) const {",
			"        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};",
			"template <class K, class V> using cmap = unordered_map<K, V, chash>;",
			""
		],
		"description": "unordered map with custom hash function"
	},
	"linear sieve": {
		"prefix": "getprimes",
		"body": [
			"vector<int> getprimes(int n) {",
			"    int is_prime[n];",
			"    vector<int> prime;",
			"    std::fill(is_prime, is_prime + n, true);",
			"    for(int i = 2; i < n; ++i) {",
			"        if(is_prime[i]) prime.push_back(i);",
			"        for(int j = 0; j < prime.size() && i * prime[j] < n; ++j) {",
			"            is_prime[i * prime[j]] = false;",
			"            if(i % prime[j] == 0) break;",
			"        }",
			"    }",
			"    return prime;",
			"}"
		],
		"description": "get prime function using linear sieve"
	},
	"heavy light decomposition": {
		"prefix": "heavylight",
		"body": [
			"template<bool EDGE> class hld {",
			"public:",
			"    // EDGE = 1 : for edge",
			"    vector<int> head, depth, pos, par, sz;",
			"    segtree<int> st;",
			"    int size = 0, n;",
			"    // base-----",
			"    hld(int n) : head(n, 0), depth(n, 0), pos(n, 0), sz(n, 1), st(n) {",
			"        this->n = n;",
			"    }",
			"",
			"    // edge weights-----",
			"    hld(int n, vector<vector<pair<int, int>>> & adj) : hld(n) {",
			"        dfs(0, adj);",
			"        decompose(0, 0, adj);",
			"        // populate(this->val);",
			"    }",
			"    ",
			"    void dfs(int node, vector<vector<pair<int, int>>> & adj) {",
			"        for(auto &x : adj[node]) if(x.first!=par[node]) {",
			"            par[x.first] = node; depth[x.first] = depth[node]+1;",
			"            dfs(x.first, adj);",
			"            sz[node]+=sz[x.first];",
			"            if(sz[x.first]>sz[adj[node][0].first]) {",
			"                swap(adj[node][0], x);",
			"            }",
			"        }",
			"    }",
			"    void decompose(int node, int h, vector<vector<pair<int, int>>> const& adj) {",
			"        head[node] = h, pos[node] = size++;",
			"        for (auto [x, w] : adj[node]) if(x!=par[node]) {",
			"            if (x == adj[node][0].first) decompose(x, h, adj);",
			"            else decompose(x, x, adj);",
			"            st.set(pos[x], w);",
			"        }",
			"    }",
			"    ",
			"    // node values----",
			"    hld(int n, vector<vector<int>> & adj, vector<int> &v) : hld(n) {",
			"        dfs(0, adj);",
			"        decompose(0, 0, adj);",
			"        for(int i = 0; i<n; i++)st.set(pos[i], v[i]);",
			"    } ",
			"",
			"    void dfs(int node, vector<vector<int>> & adj) {",
			"        for(auto &x : adj[node]) if(x!=par[node]) {",
			"            par[x] = node; depth[x] = depth[node]+1;",
			"            dfs(x, adj);",
			"            sz[node]+=sz[x];",
			"            if(sz[x]>sz[adj[node][0]]) {",
			"                swap(adj[node][0], x);",
			"            }",
			"        }",
			"    }",
			"    void decompose(int node, int h, vector<vector<int>> const& adj) {",
			"        head[node] = h, pos[node] = size++;",
			"        for (auto &x : adj[node]) if(x!=par[node]) {",
			"            if (x == adj[node][0]) decompose(x, h, adj);",
			"            else decompose(x, x, adj);",
			"        }",
			"    }",
			"    ",
			"    // query",
			"    template<class Operation>",
			"    int processpath(int a, int b) {",
			"        for (; head[a] != head[b]; b = par[head[b]]) {",
			"            if (depth[head[a]] > depth[head[b]]) swap(a, b);",
			"            Operation(pos[head[b]], pos[b]);",
			"        }",
			"        if (depth[a] > depth[b]) swap(a, b);",
			"        Operation(pos[a] + EDGE, pos[b]);",
			"        return res;",
			"    }",
			"    void pathupdate(int a, int b, int v) {",
			"        processpath(a, b, [this, &v](int l, int r) {",
			"            // tree.rangeupdate(l, r+1, v);",
			"        });",
			"    }",
			"    int pathquery(int a, int b, int v) {",
			"        int res = 0;",
			"        processpath(a, b, [this, &res](int l, int r) {",
			"            res+=tree.get(l, r+1, v);",
			"        })",
			"    }",
			"",
			"};"
		],
		"description": "heavy light decomposition"
	},
	"persistent segment tree": {
		"prefix": "persistent segment tree",
		"body": [
			"template<class T> struct Node {",
			"    int l, r;",
			"    T val;",
			"    Node(): l(-1),r(-1),val(0){}",
			"    Node(T n) : Node() {",
			"        val = n;",
			"    }",
			"};",
			"",
			"template <class T> struct PST {",
			"    #define left(x) tree[x].l",
			"    #define right(x) tree[x].r",
			"    vector<Node<T>> tree;",
			"    int n;",
			"    int sz = 0;",
			"    T base = 0;",
			"    int build(int lx, int rx, vector<T> &v) {",
			"        int node = sz++;",
			"        tree.emplace_back();",
			"        if(lx+1==rx) {",
			"            tree[node].val = v[lx];",
			"            return node;",
			"        }",
			"        int mid = (lx+rx)>>1;",
			"        tree[node].l = build(lx, mid, v);",
			"        tree[node].r = build(mid, rx, v);",
			"        tree[node].val = op(tree[left(node)].val, tree[right(node)].val);",
			"        return node;",
			"    }",
			"    int set(int prev, int i, T val, int lx, int rx) {",
			"        int node = sz++;",
			"        tree.emplace_back();",
			"        tree[node] = tree[prev];",
			"        if(lx+1 == rx) {",
			"            tree[node].val = val;",
			"            return node;",
			"        }",
			"        int mid = (lx+rx)>>1;",
			"        if(i<mid) {",
			"            left(node) = set(left(prev), i, val, lx, mid);",
			"            right(node) = right(prev);",
			"        } else {",
			"            left(node) = left(prev);",
			"            right(node) = set(right(prev), i, val, mid, rx);",
			"        }",
			"        tree[node].val = op(tree[left(node)].val, tree[right(node)].val);",
			"        return node;",
			"    }",
			"    T get(int node, int l, int r, int lx, int rx) {",
			"        if(lx>=r or l>=rx) {",
			"            return base;",
			"        }",
			"        if(lx>=l and rx<=r)return tree[node].val;",
			"        int mid = (lx+rx)>>1;",
			"        return op(get(left(node), l, r, lx, mid), get(right(node), l, r, mid, rx));",
			"    }",
			"",
			"    //--------",
			"",
			"    PST(int sz) {",
			"        n = sz;",
			"        tree.reserve(25*n);",
			"    }",
			"    T op(T l, T r) {",
			"        return l+r;",
			"    }",
			"    // [l, r) range sum of node-th tree",
			"    T get(int node, int l, int r) { return get(node, l, r, 0, n);}",
			"    // new root after point update",
			"    int set(int prev, int i, T val) { return set(prev, i, val, 0, n);}",
			"};",
			""
		],
		"description": "persistent segment tree"
	},
}